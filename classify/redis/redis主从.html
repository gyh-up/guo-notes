<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis主从 | 技术博客，知识分享，学习笔记，问题解决方案</title>
    <meta name="description" content="啊郭的博客">
    <link rel="stylesheet" href="/guo-notes/assets/style.5e0eda6f.css">
    <link rel="modulepreload" href="/guo-notes/assets/app.8b9870fe.js">
    <link rel="modulepreload" href="/guo-notes/assets/classify_redis_redis主从.md.90caa3b8.lean.js">
    
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-c6a644e1><!--[--><!--]--><!--[--><span tabindex="-1" data-v-151f2593></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-151f2593> Skip to content </a><!--]--><!----><header class="VPNav" data-v-c6a644e1 data-v-a71a30f1><div class="VPNavBar has-sidebar" data-v-a71a30f1 data-v-6f1d18b5><div class="container" data-v-6f1d18b5><div class="VPNavBarTitle has-sidebar" data-v-6f1d18b5 data-v-d5925166><a class="title" href="/guo-notes/" data-v-d5925166><!--[--><!--]--><!----><!--[-->啊郭的博客<!--]--><!--[--><!--]--></a></div><div class="content" data-v-6f1d18b5><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6f1d18b5 data-v-f83db6ba><span id="main-nav-aria-label" class="visually-hidden" data-v-f83db6ba>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-f83db6ba data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6ffb57d3><span class="text" data-v-6ffb57d3><!----> 后端技术 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-6ffb57d3><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><div class="items" data-v-1c5d0cfc><!--[--><!--[--><div class="VPMenuGroup" data-v-1c5d0cfc data-v-9ca52130><!----><!--[--><!--[--><div class="VPMenuLink" data-v-9ca52130 data-v-e8e0fb1d><a class="VPLink link" href="/guo-notes/classify/redis/redis%E4%BB%8B%E7%BB%8D.html" data-v-e8e0fb1d data-v-3c355974><!--[-->Redis<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-f83db6ba data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6ffb57d3><span class="text" data-v-6ffb57d3><!----> 计算机基础 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-6ffb57d3><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><div class="items" data-v-1c5d0cfc><!--[--><!--[--><div class="VPMenuGroup" data-v-1c5d0cfc data-v-9ca52130><!----><!--[--><!--[--><div class="VPMenuLink" data-v-9ca52130 data-v-e8e0fb1d><a class="VPLink link" href="/guo-notes/classify/计算机基础/计算机网络/" data-v-e8e0fb1d data-v-3c355974><!--[-->计算机网络<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/guo-notes/classify/algorithm/" data-v-f83db6ba data-v-47a2263e data-v-3c355974><!--[-->算法<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6f1d18b5 data-v-a3e7452b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-a3e7452b data-v-1899cd41 data-v-086e8519><span class="check" data-v-086e8519><span class="icon" data-v-086e8519><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-1899cd41><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-1899cd41><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6f1d18b5 data-v-738bef5a data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/gyh-up?tab=repositories" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a class="VPSocialLink" href="https://blog.csdn.net/weixin_42258523?spm=1000.2115.3001.5343" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><embed src="https://g.csdnimg.cn/static/logo/favicon32.ico" style="border-radius: 100%;width: 20px;height: 20px;" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6f1d18b5 data-v-e4361c82 data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6ffb57d3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6ffb57d3><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><!----><!--[--><!--[--><!----><div class="group" data-v-e4361c82><div class="item appearance" data-v-e4361c82><p class="label" data-v-e4361c82>Appearance</p><div class="appearance-action" data-v-e4361c82><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-e4361c82 data-v-1899cd41 data-v-086e8519><span class="check" data-v-086e8519><span class="icon" data-v-086e8519><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-1899cd41><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-1899cd41><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-e4361c82><div class="item social-links" data-v-e4361c82><div class="VPSocialLinks social-links-list" data-v-e4361c82 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/gyh-up?tab=repositories" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a class="VPSocialLink" href="https://blog.csdn.net/weixin_42258523?spm=1000.2115.3001.5343" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><embed src="https://g.csdnimg.cn/static/logo/favicon32.ico" style="border-radius: 100%;width: 20px;height: 20px;" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6f1d18b5 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-c6a644e1 data-v-aac27d5e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-aac27d5e><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-aac27d5e><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-aac27d5e>Menu</span></button><a class="top-link" href="#" data-v-aac27d5e> Return to top </a></div><aside class="VPSidebar" data-v-c6a644e1 data-v-f332cb62><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-f332cb62><span class="visually-hidden" id="sidebar-aria-label" data-v-f332cb62> Sidebar Navigation </span><!--[--><div class="group" data-v-f332cb62><section class="VPSidebarGroup collapsible" data-v-f332cb62 data-v-35f99ef5><div class="title" role="button" data-v-35f99ef5><h2 class="title-text" data-v-35f99ef5>Redis 学习笔记</h2><div class="action" data-v-35f99ef5><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-35f99ef5><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-35f99ef5><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-35f99ef5><!--[--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E4%BB%8B%E7%BB%8D.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>一、介绍</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>二、数据类型简介</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>三、底层数据结构</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>四、五大数据类型实现原理</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>五、redis内存淘汰策略</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>六、redis内存回收</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>七、redis内存碎片率</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>八、redis缓存击穿、穿透、雪崩</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%AE%A1%E9%81%93.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>九、redis慢查询和管道</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十、redis持久化</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E4%BA%8B%E5%8A%A1.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十一、redis事务</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十二、redis分布式锁</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/guo-notes/classify/redis/redis%E4%B8%BB%E4%BB%8E.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十三、redis主从</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E5%93%A8%E5%85%B5.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十四、redis哨兵</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/guo-notes/classify/redis/redis%E9%9B%86%E7%BE%A4.html" style="padding-left:0px;" data-v-2cfe069a data-v-3c355974><!--[--><span class="link-text" data-v-2cfe069a>十五、redis集群</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-c6a644e1 data-v-c95df128><div class="VPDoc has-sidebar has-aside" data-v-c95df128 data-v-37ebe389><div class="container" data-v-37ebe389><div class="aside" data-v-37ebe389><div class="aside-curtain" data-v-37ebe389></div><div class="aside-container" data-v-37ebe389><div class="aside-content" data-v-37ebe389><div class="VPDocAside" data-v-37ebe389 data-v-afc4c1a1><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-afc4c1a1 data-v-2865c0b0><div class="content" data-v-2865c0b0><div class="outline-marker" data-v-2865c0b0></div><div class="outline-title" data-v-2865c0b0>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-2865c0b0><span class="visually-hidden" id="doc-outline-aria-label" data-v-2865c0b0> Table of Contents for current page </span><ul class="root" data-v-2865c0b0 data-v-1188541a><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-afc4c1a1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-37ebe389><div class="content-container" data-v-37ebe389><!--[--><!--]--><main class="main" data-v-37ebe389><div style="position:relative;" class="vp-doc _guo-notes_classify_redis_redis%E4%B8%BB%E4%BB%8E" data-v-37ebe389><div><h1 id="redis主从" tabindex="-1">redis主从 <a class="header-anchor" href="#redis主从" aria-hidden="true">#</a></h1><h2 id="主从复制方式" tabindex="-1">主从复制方式 <a class="header-anchor" href="#主从复制方式" aria-hidden="true">#</a></h2><p>参与复制的 redis 实例划分为主节点 (master) 和从节点 (slave)。默认情况下，redis 都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能有主节点复制到从节点。</p><h3 id="redis对于主从复制有三种方式" tabindex="-1"><strong>redis对于主从复制有三种方式</strong> <a class="header-anchor" href="#redis对于主从复制有三种方式" aria-hidden="true">#</a></h3><ol masterHost=""><li>在配置文件中加入 slaveof {masterHost} {masterPort} 随 redis 启动生效</li><li>在 redis-server 启动命令后加入 --slaveof {masterHost} {masterPort} 生效</li><li masterPort="">直接使用命令： slaveof</li></ol><p>slaveof 命令在使用的时候，可以运行期动态配置，也可以提前写入到配置文件中。</p><p><strong>别名</strong></p><p>slaveof 的别名 REPLICATION，为啥还有个别名，说来也是挺好玩的，感兴趣可以看看下面这个链接：<a href="https://www.oschina.net/news/99797/redis-master-slave-terminology" target="_blank" rel="noreferrer">https://www.oschina.net/news/99797/redis-master-slave-terminology</a></p><p>修改配置的方式： 配置从节点的 redis.conf</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">slaveof 192.160.1.150 6379</span></span>
<span class="line"><span style="color:#676E95;"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span>
<span class="line"><span style="color:#676E95;"># masterauth &lt;master-password&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>查看复制状态信息</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">info replication</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果需要断开复制</p><p>slaveof 命令不但可以建立复制，还可以在从节点执行 <code>slaveof no one</code> 来断开与主节点复制关系。如果从节点断开了连接，那么当前的 redis 则会切换为主服务。</p><h2 id="常用配置" tabindex="-1"><strong>常用配置</strong> <a class="header-anchor" href="#常用配置" aria-hidden="true">#</a></h2><h3 id="logfile" tabindex="-1">logfile <a class="header-anchor" href="#logfile" aria-hidden="true">#</a></h3><p>日志路径</p><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">logfile &quot;/redis/log/redis.log&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="dir" tabindex="-1">dir <a class="header-anchor" href="#dir" aria-hidden="true">#</a></h3><p>数据保存目录</p><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">dir &quot;/redis/data&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="slaveof（从）" tabindex="-1">slaveof（从） <a class="header-anchor" href="#slaveof（从）" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>slave 实例需要配置该项，指向 master 的（ip, port）</p><h3 id="requirepass（主）和-masterauth（从）" tabindex="-1">requirepass（主）和 masterauth（从） <a class="header-anchor" href="#requirepass（主）和-masterauth（从）" aria-hidden="true">#</a></h3><p>设置密码安全连接。</p><p>对于数据比较重要的节点，主节点会通过设置 <code>requirepass</code> 参数进行密码验证，这时所有的客户端访问必须使用auth 命令实行验证。从节点与主节点的复制链接是通过一个特殊标识的客户端来完成，因此需要配置从节点的<code>masterauth</code> 参数与主节点密码保持一致，这样从节点才可以正确地链接到主节点并发起复制流程</p><h3 id="slave-read-only（从）" tabindex="-1">slave-read-only（从） <a class="header-anchor" href="#slave-read-only（从）" aria-hidden="true">#</a></h3><p>设置 slave 是否只读，默认 <code>slave-read-only=yes</code> 配置。</p><p>由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一 致。因此没必要就不要动这个配置。</p><h3 id="replica-serve-stale-data（从）" tabindex="-1">replica-serve-stale-data（从） <a class="header-anchor" href="#replica-serve-stale-data（从）" aria-hidden="true">#</a></h3><p>指定 slave 与 master 连接中断时的动作。默认为 yes，表明 slave 会继续应答来自 client 的请求，但这些数据可能已经过期（因为连接中断导致无法从 master 同 步）。 若配置为 no，则 slave 除正常应答 &quot;INFO&quot; 和 &quot;SLAVEOF&quot; 命令外，其余来自客户端的请求命令均会得到 &quot; SYNC with master in progress&quot; 的应答，直到该 slave与 master 的连接重建成功或该 slave 被提升为 master</p><h3 id="replica-priority（从）" tabindex="-1">replica-priority（从） <a class="header-anchor" href="#replica-priority（从）" aria-hidden="true">#</a></h3><p>指定 slave 的优先级。在不只1个 slave 存在的部署环境下，当 master 宕机时， Redis Sentinel 会将 priority 值最小的 slave 提升为 master。需要注意的是，若该配置项为 0，则对应的 slave 永远不会被 Redis Sentinel 自动提升为 master。</p><h3 id="repl-disable-tcp-nodelay（主）" tabindex="-1">repl-disable-tcp-nodelay（主） <a class="header-anchor" href="#repl-disable-tcp-nodelay（主）" aria-hidden="true">#</a></h3><p>设置是否实时发送复制数据到从节点，主从延迟问题。默认为关闭。</p><p>主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题。</p><p>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，<strong>如同机架或同机房部署。</strong></p><p>当开启时，主节点会合并较小的 TCP 数据包从而节省带宽。默认发送时间间隔取决于 Linux 的内核，一般默认为40 毫秒。这种配置节省了带宽但增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，<strong>如跨机房部署。</strong></p><h3 id="repl-timeout（主）" tabindex="-1">repl-timeout（主） <a class="header-anchor" href="#repl-timeout（主）" aria-hidden="true">#</a></h3><p>主从复制超时时间，默认60秒。</p><p><strong>对于数据量较大的主节点，比如生成的 RDB 文件超过 6GB 以上时要格外小心。</strong> 传输文件这一步操作非常耗时，速度取决于主从节点之间网络带宽，通过细致分析 Full <code>resync</code> 和 <code>MASTER &lt;-&gt; SLAVE</code> 这两行日志的时间差，可以算出 RDB 文件从创建到传输完毕消耗的总时间。如果总时间超过 repl-timeout 所配置的值（默认60秒），从节点将放弃接受 RDB 文件并清理已经下载的临时文件，导致全量复制失败；<strong>针对数据量较大的节点，建议调大 repl-timeout 参数防止出现全量同步数据超时。</strong></p><h3 id="repl-ping-slave-period（主）" tabindex="-1">repl-ping-slave-period（主） <a class="header-anchor" href="#repl-ping-slave-period（主）" aria-hidden="true">#</a></h3><p>主节点心跳检测时间间隔。默认10 秒。</p><p><strong>主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态。可通过参数 <code>repl-ping-slave-period</code> 控制发送频率。从节点在主线程中每隔 1 秒发送 <code>replconf ack {offset} </code> 命令，给主节点上报自身当前的复制偏移量。</strong></p><h3 id="repl-backlog-size（主）" tabindex="-1">repl-backlog-size（主） <a class="header-anchor" href="#repl-backlog-size（主）" aria-hidden="true">#</a></h3><p>复制积压缓冲区的大小。默认 1 MB。</p><p><strong>由于缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong></p><p>反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小（通过配置 repl-backlog-size）来设置； 例如如果网络中断的平均时间是 60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为 100KB，则复制积压缓冲区的平均需求为 6MB，保险起见， 可以设置为 12MB，来保证绝大多数断线情况都可以使用部分复制。</p><h3 id="repl-backlog-ttl（主）" tabindex="-1">repl-backlog-ttl（主） <a class="header-anchor" href="#repl-backlog-ttl（主）" aria-hidden="true">#</a></h3><p>master 没有 slave 一段时间会释放复制缓冲区的内存，repl-backlog-ttl 用来设置该时间长度。单位为秒。</p><h3 id="min-slaves-to-write（主）" tabindex="-1">min-slaves-to-write（主） <a class="header-anchor" href="#min-slaves-to-write（主）" aria-hidden="true">#</a></h3><p>redis 提供了可以让 master 停止写入的方式，如果配置了 min-slaves-to-write，健康的 slave 的个数小于 N，mater 就禁止写入。master 最少得有多少个健康的 slave 存活才能执行写命令。这个配置虽然不能保证 N 个slave 都一定能接收到master的写操作，但是能避免没有足够健康的 slave 的时候，master不能写入来避免数据丢失。<strong>设置为 0 是关闭该功能。</strong></p><h2 id="拓扑" tabindex="-1">拓扑 <a class="header-anchor" href="#拓扑" aria-hidden="true">#</a></h2><ol><li>一主一从</li><li>一主多从</li><li>树状主从结构</li></ol><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h2><p><img src="/guo-notes/redis/redis-4.png" alt="image-20210825170334947"></p><p>根据上图分析大致可以分为 6 个过程：</p><ol><li><p><strong>保存主节点(master)，</strong> 执行 slaveof 后从节点只保存主节点的地址信息便直接返回，这时建立复制流程还没有开始。</p></li><li><p>从节点 (slave) 内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会<strong>尝试与该节点建立网络连接。</strong></p></li></ol><p><img src="/guo-notes/redis/redis-5.png" alt="image-20210825170734490"></p><p>从节点会建立一个 socket 套接字，从节点建立了一个端口为 51234 的套接字，专门用于接受主节点发送的复制命令。从节点连接成功后，可查看日志文件如下：</p><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.459 * Connecting to MASTER 192.160.1.150:6379    //建立连接</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.460 * MASTER &lt;-&gt; REPLICA sync started   //主从同步开始</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.460 * Non blocking connect for SYNC fired the event. //没有阻塞同步的连接事件</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.460 * Master replied to PING, replication can continue...  //从节点发送的ping命令成功返回</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.461 * Trying a partial resynchronization (request 04aa4df6b19fbd0ea4aea54ca856ed91bf6c861c:17027).</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.464 * Full resync from master: 0deae7db14cf069bf86408b8abecedf08952c0a8:0</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.464 * Discarding previously cached master state.</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.537 * MASTER &lt;-&gt; REPLICA sync: receiving 210 bytes from master</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.537 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.537 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:57:33.537 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span></span>
<span class="line"><span style="color:#A6ACCD;">114:S 28 Apr 2020 18:58:31.326 * REPLICAOF would result into synchronization with the master we are already connected with. No operation</span></span>
<span class="line"><span style="color:#A6ACCD;">performed.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>如果从节点无法建立连接，定时任务会无限重试直到连接成功或者执行 slaveof no one 取消复制。</p><p>关于连接失败，可以在从节点执行 <code>info replication</code> 查看 <code>master_link_down_since_seconds</code> 指标，它会记录与主节点连接失败的系统时间。从节点连接主节点失败 时也会每秒打印如下日志，方便发现问题：</p><p><img src="/guo-notes/redis/redis-6.png" alt="image-20210825171136030"></p><ol start="3"><li><strong>发送 ping 命令</strong></li></ol><p>连接建立成功后从节点发送 ping 请求进行首次通信， ping 请求主要目的如下：</p><p>— 检测主从之间网络套接字是否可用。</p><p>— 检测主节点当前是否可接受处理命令。</p><p>如果发送 ping 命令后，从节点没有收到主节点的 pong 回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连。</p><img src="/guo-notes/redis/redis-7.png" alt="image-20210825171348997" style="zoom:33%;"><img src="/guo-notes/redis/redis-8.png" alt="image-20210825171427102" style="zoom:33%;"><ol start="4"><li><strong>权限验证</strong> 如果主节点设置了 requirepass 参数，则需要密码验证，从节点必须配置 masterauth 参数保证与主节点相同的密码才能通过验证；如果验证失败复制将终止，从节点重新发起复制流程。</li><li><strong>同步数据集</strong> 主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。</li><li><strong>命令持续复制</strong> 当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。 <strong>注意：主从在同步的过程当中，会把原本的从节点的数据清空</strong></li></ol><h2 id="数据同步" tabindex="-1">数据同步 <a class="header-anchor" href="#数据同步" aria-hidden="true">#</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-hidden="true">#</a></h3><h4 id="全量复制" tabindex="-1">全量复制 <a class="header-anchor" href="#全量复制" aria-hidden="true">#</a></h4><p>用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作，当数据量较大时，会对主从节点和网络造成很大的开销。</p><h4 id="部分复制" tabindex="-1">部分复制 <a class="header-anchor" href="#部分复制" aria-hidden="true">#</a></h4><p>用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果（条件允许)，主节点会补发丢失数据给从节点。 因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销，需要注意的是，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</p><h4 id="复制偏移量" tabindex="-1">复制偏移量 <a class="header-anchor" href="#复制偏移量" aria-hidden="true">#</a></h4><p>参与复制的主从节点都会维护自身复制偏移量。主节点（master）在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info relication 中的 master_repl_offset 指标中：</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">127.0.0.1:</span><span style="color:#89DDFF;">6379&gt;</span><span style="color:#A6ACCD;"> info replication</span></span>
<span class="line"><span style="color:#676E95;"># Replication</span></span>
<span class="line"><span style="color:#A6ACCD;">role:master</span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">master_repl_offset:6104</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>从节点（slave）每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量，统计指标如下</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">127.0.0.1:</span><span style="color:#89DDFF;">6379&gt;</span><span style="color:#A6ACCD;"> info replication</span></span>
<span class="line"><span style="color:#676E95;"># Replication</span></span>
<span class="line"><span style="color:#A6ACCD;">role:master</span></span>
<span class="line"><span style="color:#A6ACCD;">connected_slaves:1</span></span>
<span class="line"><span style="color:#A6ACCD;">slave0:ip=192.160.1.140,port=6379,state=online,offset=6104,lag=1</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在 info relication 中的slave_repl_offset 中。</p><img src="/guo-notes/redis/redis-9.png" alt="image-20210825173132889" style="zoom:67%;"><h4 id="复制积压缓冲区" tabindex="-1">复制积压缓冲区 <a class="header-anchor" href="#复制积压缓冲区" aria-hidden="true">#</a></h4><p>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为 1MB，当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令 时，<strong>不但会把命令发送给从节点，还会写入复制积压缓冲区。</strong></p><p><img src="/guo-notes/redis/redis-10.png" alt="image-20210825173409729"></p><p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量(offset) 。由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><h4 id="主节点运行id" tabindex="-1">主节点运行ID <a class="header-anchor" href="#主节点运行id" aria-hidden="true">#</a></h4><p><strong>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。</strong> 运行ID的主要作用是用来唯一识别 Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集(如替换RDB/AOF文件)，从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。</p><p>可以运行info server命令查看当前节点的运行ID:</p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">127.0.0.1:</span><span style="color:#89DDFF;">6379&gt;</span><span style="color:#A6ACCD;"> info server</span></span>
<span class="line"><span style="color:#676E95;"># Server</span></span>
<span class="line"><span style="color:#A6ACCD;">redis_version:5.0.7</span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">run_id:868a5d49a276620b9f79788a1c894f07bd872f56</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>需要注意的是Redis关闭再启动，运行的id会随之变化</strong></p><div class="language-bash line-numbers-mode"><button class="copy"></button><span class="lang">bash</span><pre><code><span class="line"><span style="color:#A6ACCD;">redis-cli shutdown</span></span>
<span class="line"><span style="color:#A6ACCD;">redis-server redis.conf</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="psync-命令" tabindex="-1">Psync 命令 <a class="header-anchor" href="#psync-命令" aria-hidden="true">#</a></h4><p>从节点使用 psync 命令完成部分复制和全量复制功能 <code>psync runid offset</code></p><ul><li>runId：从节点所复制主节点的运行id。</li><li>offset：当前从节点已复制的数据偏移量。 流程说明：</li></ul><ol><li><p>从节点 (slave) 发送 psync 命令给主节点，参数 runid 是当前从节点保存的主节点运行id，<strong>如果没有则默认值为 ？</strong>, 参数 offset 是当前从节点保存的复制偏移量，<strong>如果是第一次参与复制则默认值为 -1</strong></p></li><li><p>主节点 (master) 根据 psync 参数和自身数据情况决定响应结果：</p></li></ol><p>— 如果回复 <strong>+FULLRESYNC {runid} {offset}，</strong> 那么从节点将厨房全量复制流程。</p><p>— 如果回复 <strong>+CONTINUE，</strong> 从节点将触发部分复制流程。</p><p>— 如果回复 <strong>+ERR，</strong> 说明主节点版本低于 Redis2.8</p><h2 id="全量复制流程" tabindex="-1">全量复制流程 <a class="header-anchor" href="#全量复制流程" aria-hidden="true">#</a></h2><p>注意： 从节点在载入主节点的数据之前要先将从节点旧数据清除</p><p>全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的阶段。触发全流量复制的命令是 sync 和 psync。</p><p><img src="/guo-notes/redis/redis-11.png" alt="image-20210826094219857"></p><p><strong>流程说明</strong></p><ol><li><p>发送 psync 命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行 id，所以发送 <code>psync ? -1</code></p></li><li><p>主节点根据 <code>psync ? -1</code> 解析出当前为全量复制，回复 <code>+FULLRESYNC</code> 响应(主机会向从机发送 <code>runid</code> 和 <code>offset</code>，因为 <code>slave</code> 并没有对应的 <code>offset</code>，所以是全量复制</p></li><li><p>从节点接收主节点的响应数据保存 <code>runid</code> 和偏移量 <code>offset</code>(从机 slave 会保存主机 master 的基本信息 save masterInfo)</p></li><li><p><strong>主节点收到全量复制的命令后，执行 bgsave（异步执行）</strong>，在后台生成 RDB 文件（快照），并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行 的所有写命令</p></li><li><p>主节点发送 RDB 文件给从节点，从节点把接收到的 RDB 文件保存在本地并直接作为从节点的数据文件，接收完 RDB 后从节点打印相关日志，可以在日志中查看主节点发送的数据量(主机 send RDB 发送 RDB 文件给从机)</p><p><img src="/guo-notes/redis/redis-12.png" alt="image-20210826094713061"></p><p>注意！<strong>对于数据量较大的主节点，比如生成的 RDB 文件超过 6GB 以上时要格外小心。</strong> 传输文件这一步操作非常耗时，速度取决于主从节点之间网络带宽，通过细致分析 <code>Full resync</code> 和 <code>MASTER &lt;-&gt; SLAVE</code> 这两行日志的时间差，可以算出 RDB 文件从创建到传输完毕消耗的总时间。如果总时间超过 repl-timeout 所配置的值（默认60秒），从节点将放弃接受 RDB 文件并清理已经下载的临时文件，导致全量复制失败；<strong>针对数据量较大的节点，建议调大 repl-timeout 参数防止出现全量同步 数据超时。</strong></p><p><strong>例如对于千兆网卡的机器，网卡带宽理论峰值大约每秒传输 100MB，在不考虑其他进程消耗带宽的情况下，6GB的RDB文件至少需要60秒传输时间，默认配置 下，极易出现主从数同步超时。</strong></p></li><li><p>对于从节点开始接收 RDB 快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完 RDB 文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据致性。</p></li><li><p>从节点接收完主节点传送来的全部数据后会清空自身旧数据（刷新旧的数据，从节点在载入主节点的数据之前要先将老数据清除）</p></li><li><p>从节点清空数据后开始加载 RDB 文件，对于较大的 RDB 文件，这一步操作依然比较消耗时间，可以通过计算日志之间的实际差来判断加载 RDB 的总消耗时间（加载 RDB 文件将数据库状态更新至主节点执行 bgsave 时的数据库状态和缓冲区数据的加载)</p></li></ol><p><img src="/guo-notes/redis/redis-13.png" alt="image-20210826095519001"></p><ol start="9"><li>从节点成功加载完 RDB 后，如果当前节点开启了 AOF 持久化的功能，它会立刻做 bgrewriteeaof 的操作，为了保证全量复制后 AOF 持久化文件立刻可用。 通过分析全量复制的所有流程，全量复制是一个非常耗时费力的操作。他的实际开销主要包括： —— 主节点 bgsave 时间 —— RDB 文件网络传输时间 —— 从节点清空数据时间 —— 从节点加载 RDB 的时间 —— 可能的 AOF 重写时间</li></ol><h2 id="部分复制流程" tabindex="-1">部分复制流程 <a class="header-anchor" href="#部分复制流程" aria-hidden="true">#</a></h2><p>部分复制是 Redis 2.8 以后出现的，之所以要加入部分复制，是因为全量复制会产生很多问题，比如像上面的时间开销大、无法隔离等问题， Redis 希望能够在 master 出现抖动（相当于断开连接）的时候，可以有一些机制将复制的损失降低到最低。</p><p><img src="/guo-notes/redis/redis-14.png" alt="image-20210826095744571"></p><ol><li>当主从节点之间网络出现中断时，如果超过 repl-timeout 时间，主节点会认为从节点出问题了并断开复制链接（如果网络抖动（连接断开 connection lost）)</li><li>主从连接中断期间主节点依然响应命令，但因复制链接中断命令无法发送给从节点。不过主节点内部存在的复制积压缓存区，依然可以保存一段时间的写命令数据，默认最大缓存 1MB（主机 master 还是会写 repl-back-buffer（复制缓冲区）)</li><li>当主从节点网络恢复后，从节点会再次连上主节点。(从机 slave 会继续尝试连接主机)</li><li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 id。因此会把他们当作psync 参数发送给主节点，要求进行部分复制操作。(从机 slave 会把自己当前 runid 和偏移量传输给主机 master，并且执行 pysnc 命令同步)</li><li>主节点接到 psync 命令后首先核对参数的 runid，如果 master 发现你的偏移量是在缓冲区的范围内，根据参数 offset 在缓冲区查找复制内容，如果在偏移量之后的数据存在缓存区中，则对从节点发送 continue 表示可以进行部分复制</li><li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。(同步了 offset 的部分数据，所以部分复制的基础就是偏移量 offset)</li></ol><h2 id="心跳检测" tabindex="-1"><strong>心跳检测</strong> <a class="header-anchor" href="#心跳检测" aria-hidden="true">#</a></h2><p>主节点在建立成功后会维护这长连接彼此发送心跳检测。</p><p>主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过<code>client list</code>命令查看复制相关客户端信息，主节点的连接状态为<code>flags=M</code>，从节点连接 状<code>flags=S</code></p><p>主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数 <code>replping-slave-period</code> 控制发送频率。</p><p>从节点在主线程中每隔 1 秒发送 <code>replconf ack {offset} </code>命令，给主节点上报自身当前的复制偏移量。</p><h2 id="复制积压缓冲区大小调节" tabindex="-1">复制积压缓冲区大小调节 <a class="header-anchor" href="#复制积压缓冲区大小调节" aria-hidden="true">#</a></h2><p><strong>由于缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong></p><p>反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小（通过配置 repl-backlog-size）来设置； 例如如果网络中断的平均时间是 60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见， 可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><h2 id="redis主从问题处理" tabindex="-1">redis主从问题处理 <a class="header-anchor" href="#redis主从问题处理" aria-hidden="true">#</a></h2><h3 id="读写分离" tabindex="-1">读写分离 <a class="header-anchor" href="#读写分离" aria-hidden="true">#</a></h3><p>读流量分摊到从节点。这是个非常好的特性，如果一个业务只需要读数据，那么我们只需要连一台 slave 从机读数据。</p><p><img src="/guo-notes/redis/redis-15.png" alt="image-20210826105935924"></p><p>虽然读写有优势，能够让读这部分分配给各个 slave 从机，如果不够，直接加 slave 机器就好了。但是也会出现以下问题。</p><h4 id="复制数据延迟" tabindex="-1">复制数据延迟 <a class="header-anchor" href="#复制数据延迟" aria-hidden="true">#</a></h4><p>Redis 复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况，比如刚在主节点写人数据后立刻在从节点上读取可能获取不到，需要业务场景允许短时间内的数据延迟。</p><p>对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。处理说明：监控程序(monitor)定期检查主从节点的偏移量，主节点偏移量在info replication的master_repl_offset 指标记录，从节点偏移量可以查询主节点的 slave0 字段的offset指标，它们的差值就是主从节点延迟的字节量。</p><p>同时从节点的 <code>slave-serve-stale-data</code> 参数也与此有关，当从库同主机失去连接或者复制正在进行，从机库有两种运行方式</p><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。</span></span>
<span class="line"><span style="color:#A6ACCD;">2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="读取过期数据" tabindex="-1">读取过期数据 <a class="header-anchor" href="#读取过期数据" aria-hidden="true">#</a></h4><p>当主节点存储大量设置超时的数据时，redis 内部需要维护过期数据删除策略，删除策略主要有两种：惰性删除和定时删除；</p><p>惰性删除：主节点每次处理读取命令时，都会检查键是否超时，如果超时则执行 del 命令删除键对象，之后 del命令也会异步发送给从节点。因为保持复制的一致性，从节点自身永远不会主动删除超时数据。</p><p>定时删除：Redis主节点在内部定时任务会循环采样一定数据量的键，当发现采样的键过期时执行 del 命令，之后再同步给从节点</p><h4 id="从节点故障问题" tabindex="-1">从节点故障问题 <a class="header-anchor" href="#从节点故障问题" aria-hidden="true">#</a></h4><p>对于从节点的故障问题，需要在客户端维护一个可用从节点可用列表，当从节点故障时，立刻切换到其他从节点或主节点，后面 redis Cluster 时候可以解决这个问题</p><h4 id="异步复制导致数据丢失" tabindex="-1">异步复制导致数据丢失 <a class="header-anchor" href="#异步复制导致数据丢失" aria-hidden="true">#</a></h4><p>因为 master-&gt;slave 的复制是异步，所以可能有部分还没来得及复制到slave就宕机了，此时这些部分数据就丢失了。</p><p>怎么解决?(请记住只能降低到可控范围,没办法做到100%不丢失)</p><div class="language- line-numbers-mode"><button class="copy"></button><span class="lang"></span><pre><code><span class="line"><span style="color:#A6ACCD;">#最少有多少台从机器才能写入</span></span>
<span class="line"><span style="color:#A6ACCD;">min-slaves-to-write 1</span></span>
<span class="line"><span style="color:#A6ACCD;">#从节点最大延迟时间,延迟小于min-slaves-max-lag秒的slave才认为是健康的slave</span></span>
<span class="line"><span style="color:#A6ACCD;">min-slaves-max-lag 10</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>要求至少有1个slave，数据复制和同步的延迟不能超过10秒</p><p>如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master 就不会再接收任何请求了</p><p>有了 min-slaves-max-lag 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到slave导致的数据丢失降低到可控范围内</p><p>如何选择，要不要读写分离？</p><p>没有最合适的方案，只有最合适的场景，读写分离需要业务可以容忍一定程度的数据不一致，适合读多写少的业务场景，读写分离，主要是因为要建立一主多从的架构，才能横向任意扩展 slave node 去支撑更大的读吞吐量。</p><h3 id="配置不一致" tabindex="-1">配置不一致 <a class="header-anchor" href="#配置不一致" aria-hidden="true">#</a></h3><p>主机和从机不同，经常导致主机和从机的配置不同，并带来问题。</p><p>主从配置不一致是一个容易忽视的问题。对于有些配置主从之间是可以不一致，比如:主节点关闭AOF在从节点开启。但对于内存相关的配置必须要一致， 比如maxmemory, hash-max-ziplist-entries等参数。</p><p>数据丢失： 主机和从机有时候会发生配置不一致的情况，例如 maxmemory 不一致，如果主机配置 maxmemory 为8G，从机 slave 设置为4G，这个时候是可 以用的，而且还不会报错。 但是如果要做高可用，让从节点变成主节点的时候，就会发现数据已经丢失了，而且无法挽回。</p><h3 id="规避全量复制" tabindex="-1">规避全量复制 <a class="header-anchor" href="#规避全量复制" aria-hidden="true">#</a></h3><p>全量复制指的是当 slave 从机断掉并重启后，runid 产生变化而导致需要在 master 主机里拷贝全部数据。这种拷贝全部数据的过程非常耗资源。</p><p>全量复制是不可避免的，例如第一次的全量复制是不可避免的，这时我们需要选择小主节点，且 maxmemory （用于控制redis可使用的最大内存容量）值不要过大，这样就会比较快。同时选择在低峰值的时候做全量复制。</p><p><strong>造成全量复制的原因</strong></p><p>1、是主从机的运行 runid 不匹配。解释一下，主节点如果重启， runid 将会发生变化。如果从节点监控到 runid 不是同一个，它就会认为你的节点不安全。 当发生故障转移的时候，如果主节点发生故障，那么从机就会变成主节点。我们会在后面讲解哨兵和集群。</p><p>2、复制缓冲区空间不足，比如默认值 1M，可以部分复制。但如果缓存区不够大的话，首先需要网络中断，部分复制就无法满足。其次需要增大复制缓冲区配置（rel-back-log-size），对网络的缓冲增强。参考之前的说明</p><p><strong>怎么解决</strong></p><p>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得 runid 发生变化，可能导致不必要的全量复制。</p><p>为了解决这个问题，Redis 提供了 debug reload 的重启方式：重启后，主节点的 runid 和 offset 都不受影响，避免了全量复制</p><h3 id="规避复制风暴" tabindex="-1">规避复制风暴 <a class="header-anchor" href="#规避复制风暴" aria-hidden="true">#</a></h3><p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成<strong>大量开销，导致CPU、内存、带宽消耗</strong>。因此我们应该分析出复制风暴发生的场景，提前采用合理的方式规避。规避方式有如下几个。 这些在之后哨兵和redis内存的时候讲解。</p><h4 id="单节点复制风暴" tabindex="-1">单节点复制风暴 <a class="header-anchor" href="#单节点复制风暴" aria-hidden="true">#</a></h4><p>当一个主机下面挂了很多个 slave 从机的时候，主机 master 挂了，这时 master 主机重启后，因为 runid 发生了变化，所有的 slave 从机都要做一次全量复制。这将引起单节点和单机器的复制风暴，开销会非常大。</p><p><img src="/guo-notes/redis/redis-25.png" alt="image-20210826103043136"></p><p>解决：</p><p>可以采用树状结构降低多个从节点对主节点的消耗</p><p>从节点采用树状树非常有用，网络开销交给位于中间层的从节点，而不必消耗顶层的主节点。但是这种树状结构也带来了运维的复杂性，增加了手动和自动处理故障转移的难度</p><h4 id="单机器复制风暴" tabindex="-1">单机器复制风暴 <a class="header-anchor" href="#单机器复制风暴" aria-hidden="true">#</a></h4><p>由于 Redis 的单线程架构，通常单台机器会部署多个 Redis 实例。当一台机器（machine）上同时部署多个主节点 （master） 时，如果每个 master 主机只有一台 slave 从机，那么当机器宕机以后，会产生大量全量复制。这种情况是非常危险的情况，带宽马上会被占用，会导致不可用。</p><p><img src="/guo-notes/redis/redis-26.png" alt="redis-22"></p><p>解决：</p><p>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</p><p>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制</p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-37ebe389 data-v-a54a85bd><div class="edit-info" data-v-a54a85bd><!----><div class="last-updated" data-v-a54a85bd><p class="VPLastUpdated" data-v-a54a85bd data-v-f7d51a9c>Last updated: <time datatime="2023-02-19T16:20:41.000Z" data-v-f7d51a9c></time></p></div></div><div class="prev-next" data-v-a54a85bd><div class="pager" data-v-a54a85bd><a class="pager-link prev" href="/guo-notes/classify/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html" data-v-a54a85bd><span class="desc" data-v-a54a85bd>Previous page</span><span class="title" data-v-a54a85bd>十二、redis分布式锁</span></a></div><div class="has-prev pager" data-v-a54a85bd><a class="pager-link next" href="/guo-notes/classify/redis/redis%E5%93%A8%E5%85%B5.html" data-v-a54a85bd><span class="desc" data-v-a54a85bd>Next page</span><span class="title" data-v-a54a85bd>十四、redis哨兵</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"classify_algorithm_concept_复杂度-时间复杂度和空间复杂度.md\":\"5e05856c\",\"classify_algorithm_concept_数据结构-堆.md\":\"82f00316\",\"classify_algorithm_concept_数据结构-栈与队列.md\":\"f8e132ae\",\"classify_algorithm_concept_数据结构-树.md\":\"ee3f7026\",\"classify_algorithm_concept_算法-排序算法.md\":\"3bc40aa3\",\"classify_algorithm_concept_算法-查找算法.md\":\"0d2f0fe6\",\"classify_algorithm_concept_算法-深度优先搜索和广度优先搜索.md\":\"8ad73bb6\",\"classify_algorithm_index.md\":\"e4faa5f8\",\"classify_algorithm_title_leetcode-1.md\":\"eb6271bc\",\"classify_algorithm_title_leetcode-101.md\":\"0979a1a0\",\"classify_algorithm_title_leetcode-104.md\":\"82a66d5e\",\"classify_algorithm_title_leetcode-110.md\":\"ee5752f7\",\"classify_algorithm_title_leetcode-141.md\":\"19e9e404\",\"classify_algorithm_title_leetcode-142.md\":\"801a6cca\",\"classify_algorithm_title_leetcode-144.md\":\"979a91c0\",\"classify_algorithm_title_leetcode-145.md\":\"ce11150b\",\"classify_algorithm_title_leetcode-160.md\":\"05d67425\",\"classify_algorithm_title_leetcode-206.md\":\"0d69a1a0\",\"classify_algorithm_title_leetcode-21.md\":\"a5018aa8\",\"classify_algorithm_title_leetcode-226.md\":\"d8999d84\",\"classify_algorithm_title_leetcode-232.md\":\"5a06c003\",\"classify_algorithm_title_leetcode-234.md\":\"ffdb23aa\",\"classify_algorithm_title_leetcode-283.md\":\"cf55be9b\",\"classify_algorithm_title_leetcode-394.md\":\"905583b4\",\"classify_algorithm_title_leetcode-448.md\":\"3bbc9bd3\",\"classify_algorithm_title_leetcode-70.md\":\"4a6fffaa\",\"classify_algorithm_title_leetcode-83.md\":\"3315676d\",\"classify_algorithm_title_leetcode-876.md\":\"4b6c8ddf\",\"classify_algorithm_title_leetcode-88.md\":\"713073a3\",\"classify_algorithm_title_leetcode-912.md\":\"601069a7\",\"classify_algorithm_title_leetcode-94.md\":\"98adcb59\",\"classify_algorithm_title_leetcode-模板.md\":\"186d4dcc\",\"classify_algorithm_title_剑指offer-22.md\":\"c5da8eb5\",\"classify_algorithm_其他-设计.md\":\"824d341f\",\"classify_algorithm_基础-排序.md\":\"12c31082\",\"classify_algorithm_基础数据结构-哈希表.md\":\"98e53e0c\",\"classify_algorithm_基础数据结构-字符串.md\":\"945d40bf\",\"classify_algorithm_基础数据结构-数组.md\":\"c4bff841\",\"classify_algorithm_基础数据结构-栈.md\":\"c05e49ef\",\"classify_algorithm_基础数据结构-树.md\":\"72a6bbe9\",\"classify_algorithm_基础数据结构-链表.md\":\"4c2cb14a\",\"classify_algorithm_基础数据结构-队列.md\":\"1649dde2\",\"classify_algorithm_技巧-双指针.md\":\"cb016066\",\"classify_algorithm_数学-斐波那契数列.md\":\"d18cf38c\",\"classify_algorithm_数学-相遇问题.md\":\"63c4ead9\",\"classify_algorithm_算法-动态规划.md\":\"1075177b\",\"classify_algorithm_算法-广度优先搜索.md\":\"f0b85dff\",\"classify_algorithm_算法-排序.md\":\"29a6baab\",\"classify_algorithm_算法-深度优先搜索.md\":\"f9612fc8\",\"classify_algorithm_算法-迭代.md\":\"0fdeca6f\",\"classify_algorithm_算法-递归.md\":\"6dc518db\",\"classify_redis_redis主从.md\":\"90caa3b8\",\"classify_redis_redis事务.md\":\"e40f6f16\",\"classify_redis_redis五大数据类型实现原理.md\":\"3df381e9\",\"classify_redis_redis介绍.md\":\"053aa68f\",\"classify_redis_redis内存回收.md\":\"7f9ad4e1\",\"classify_redis_redis内存淘汰策略.md\":\"3a569607\",\"classify_redis_redis内存碎片率.md\":\"d65d96f1\",\"classify_redis_redis分布式锁.md\":\"ff536e3b\",\"classify_redis_redis哨兵.md\":\"5935c372\",\"classify_redis_redis底层数据结构.md\":\"880ae7f5\",\"classify_redis_redis慢查询和管道.md\":\"3bee3e21\",\"classify_redis_redis持久化.md\":\"474057bf\",\"classify_redis_redis数据类型简介.md\":\"ff822679\",\"classify_redis_redis缓存击穿、穿透、雪崩.md\":\"25660d30\",\"classify_redis_redis配置文件解析.md\":\"0dc7e658\",\"classify_redis_redis集群.md\":\"c913e517\",\"classify_sundry_tools_git_github 连接失败.md\":\"65d46106\",\"classify_sundry_tools_vscode_vscode 启动 debug.md\":\"8ca9338c\",\"classify_框架学习_laravel_artisan控制台命令.md\":\"5ff5f4bb\",\"classify_框架学习_laravel_生命周期相关核心概念.md\":\"51dcdee2\",\"classify_解决方案_redis主从存在的问题和解决方案.md\":\"2090b952\",\"classify_解决方案_数据库与缓存一致性解决方案.md\":\"f7f3bfa6\",\"classify_计算机基础_计算机网络_io模型.md\":\"f3fce356\",\"classify_计算机基础_计算机网络_index.md\":\"170d1cf5\",\"index.md\":\"eeb174dc\",\"preface_install.md\":\"55c92506\",\"preface_preface.md\":\"7af430d0\",\"学习网址.md\":\"1a5b6f55\",\"网站常用.md\":\"593f6f7d\"}")</script>
    <script type="module" async src="/guo-notes/assets/app.8b9870fe.js"></script>
    
  </body>
</html>